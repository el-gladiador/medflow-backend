package service

import (
	"bytes"
	"context"
	"fmt"
	"time"

	"github.com/go-pdf/fpdf"
)

// ExportInventoryRegister generates a PDF inventory register
func (s *InventoryService) ExportInventoryRegister(ctx context.Context) ([]byte, error) {
	items, err := s.itemRepo.GetAllActive(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get items: %w", err)
	}

	pdf := fpdf.New("L", "mm", "A4", "")
	pdf.SetAutoPageBreak(true, 15)

	// Header
	pdf.SetHeaderFunc(func() {
		pdf.SetFont("Arial", "B", 14)
		pdf.Cell(0, 10, "Inventory Register / Bestandsverzeichnis")
		pdf.Ln(6)
		pdf.SetFont("Arial", "", 9)
		pdf.Cell(0, 6, fmt.Sprintf("Generated: %s", time.Now().Format("2006-01-02 15:04")))
		pdf.Ln(10)
	})

	// Footer
	pdf.SetFooterFunc(func() {
		pdf.SetY(-15)
		pdf.SetFont("Arial", "I", 8)
		pdf.CellFormat(0, 10, fmt.Sprintf("Page %d/{nb} - Generated by MedFlow", pdf.PageNo()), "", 0, "C", false, 0, "")
	})
	pdf.AliasNbPages("")

	pdf.AddPage()

	// Table header
	colWidths := []float64{50, 25, 35, 25, 35, 30, 25, 20, 20, 25}
	headers := []string{"Name", "Category", "Manufacturer", "CE Marking", "UDI-DI", "Article No.", "Barcode", "Unit", "Min Stock", "Location"}

	pdf.SetFont("Arial", "B", 8)
	pdf.SetFillColor(220, 220, 220)
	for i, h := range headers {
		pdf.CellFormat(colWidths[i], 7, h, "1", 0, "C", true, 0, "")
	}
	pdf.Ln(-1)

	// Table rows
	pdf.SetFont("Arial", "", 7)
	fill := false
	for _, item := range items {
		if fill {
			pdf.SetFillColor(245, 245, 245)
		} else {
			pdf.SetFillColor(255, 255, 255)
		}

		name := truncate(item.Name, 30)
		category := item.Category
		manufacturer := deref(item.Manufacturer)
		ceMarking := deref(item.CEMarkingNumber)
		udiDI := deref(item.UdiDI)
		articleNo := deref(item.ArticleNumber)
		barcode := deref(item.Barcode)
		unit := item.Unit
		minStock := fmt.Sprintf("%d", item.MinStock)
		location := ""
		if item.DefaultLocationID != nil {
			location = truncate(*item.DefaultLocationID, 15)
		}

		pdf.CellFormat(colWidths[0], 6, name, "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[1], 6, category, "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[2], 6, truncate(manufacturer, 20), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[3], 6, truncate(ceMarking, 15), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[4], 6, truncate(udiDI, 20), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[5], 6, truncate(articleNo, 18), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[6], 6, truncate(barcode, 15), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[7], 6, unit, "1", 0, "C", fill, 0, "")
		pdf.CellFormat(colWidths[8], 6, minStock, "1", 0, "C", fill, 0, "")
		pdf.CellFormat(colWidths[9], 6, location, "1", 0, "L", fill, 0, "")
		pdf.Ln(-1)

		fill = !fill
	}

	var buf bytes.Buffer
	if err := pdf.Output(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate PDF: %w", err)
	}

	return buf.Bytes(), nil
}

// ExportGefahrstoffverzeichnis generates a hazardous substance register PDF (GefStoffV §6)
func (s *InventoryService) ExportGefahrstoffverzeichnis(ctx context.Context) ([]byte, error) {
	hazItems, err := s.ListAllHazardousItems(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get hazardous items: %w", err)
	}

	pdf := fpdf.New("L", "mm", "A4", "")
	pdf.SetAutoPageBreak(true, 15)

	// Header
	pdf.SetHeaderFunc(func() {
		pdf.SetFont("Arial", "B", 14)
		pdf.Cell(0, 10, "Gefahrstoffverzeichnis / Hazardous Substance Register")
		pdf.Ln(6)
		pdf.SetFont("Arial", "", 9)
		pdf.Cell(0, 6, fmt.Sprintf("Erstellt: %s | gem. GefStoffV \u00a76", time.Now().Format("2006-01-02 15:04")))
		pdf.Ln(10)
	})

	// Footer
	pdf.SetFooterFunc(func() {
		pdf.SetY(-15)
		pdf.SetFont("Arial", "I", 8)
		pdf.CellFormat(0, 10, fmt.Sprintf("Seite %d/{nb} - Generated by MedFlow", pdf.PageNo()), "", 0, "C", false, 0, "")
	})
	pdf.AliasNbPages("")

	pdf.AddPage()

	// Table header
	colWidths := []float64{40, 30, 22, 35, 35, 35, 35, 45}
	headers := []string{"Bezeichnung", "GHS-Piktogramme", "Signalwort", "H-Saetze", "P-Saetze", "Einsatzbereich", "Lagerort", "Lagerhinweise"}

	pdf.SetFont("Arial", "B", 7)
	pdf.SetFillColor(220, 220, 220)
	for i, h := range headers {
		pdf.CellFormat(colWidths[i], 7, h, "1", 0, "C", true, 0, "")
	}
	pdf.Ln(-1)

	// Table rows
	pdf.SetFont("Arial", "", 7)
	fill := false
	for _, hi := range hazItems {
		if fill {
			pdf.SetFillColor(245, 245, 245)
		} else {
			pdf.SetFillColor(255, 255, 255)
		}

		name := truncate(hi.Item.Name, 25)
		ghsCodes := ""
		signalWord := ""
		hStatements := ""
		pStatements := ""
		usageArea := ""
		storageInstr := ""
		location := ""

		if hi.Details != nil {
			ghsCodes = deref(hi.Details.GHSPictogramCodes)
			signalWord = deref(hi.Details.SignalWord)
			hStatements = deref(hi.Details.HStatements)
			pStatements = deref(hi.Details.PStatements)
			usageArea = deref(hi.Details.UsageArea)
			storageInstr = deref(hi.Details.StorageInstructions)
		}
		if hi.Item.DefaultLocationID != nil {
			location = truncate(*hi.Item.DefaultLocationID, 20)
		}

		pdf.CellFormat(colWidths[0], 6, name, "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[1], 6, truncate(ghsCodes, 18), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[2], 6, truncate(signalWord, 12), "1", 0, "C", fill, 0, "")
		pdf.CellFormat(colWidths[3], 6, truncate(hStatements, 22), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[4], 6, truncate(pStatements, 22), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[5], 6, truncate(usageArea, 22), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[6], 6, truncate(location, 22), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[7], 6, truncate(storageInstr, 28), "1", 0, "L", fill, 0, "")
		pdf.Ln(-1)

		fill = !fill
	}

	if len(hazItems) == 0 {
		pdf.SetFont("Arial", "I", 10)
		pdf.Ln(5)
		pdf.Cell(0, 10, "Keine Gefahrstoffe erfasst / No hazardous substances registered.")
	}

	var buf bytes.Buffer
	if err := pdf.Output(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate PDF: %w", err)
	}

	return buf.Bytes(), nil
}

// ExportBestandsverzeichnis generates a Bestandsverzeichnis PDF per MPBetreibV §14
func (s *InventoryService) ExportBestandsverzeichnis(ctx context.Context) ([]byte, error) {
	items, err := s.itemRepo.ListMedicalDevices(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get medical devices: %w", err)
	}

	pdf := fpdf.New("L", "mm", "A4", "")
	pdf.SetAutoPageBreak(true, 15)

	// Header
	pdf.SetHeaderFunc(func() {
		pdf.SetFont("Arial", "B", 14)
		pdf.Cell(0, 10, "Bestandsverzeichnis / Medical Device Register")
		pdf.Ln(6)
		pdf.SetFont("Arial", "", 9)
		pdf.Cell(0, 6, fmt.Sprintf("Erstellt: %s | gem. MPBetreibV \u00a714", time.Now().Format("2006-01-02 15:04")))
		pdf.Ln(10)
	})

	// Footer
	pdf.SetFooterFunc(func() {
		pdf.SetY(-15)
		pdf.SetFont("Arial", "I", 8)
		pdf.CellFormat(0, 10, fmt.Sprintf("Seite %d/{nb} - Generated by MedFlow", pdf.PageNo()), "", 0, "C", false, 0, "")
	})
	pdf.AliasNbPages("")

	pdf.AddPage()

	// Table header
	colWidths := []float64{10, 35, 22, 22, 18, 30, 22, 20, 22, 15, 25, 25, 25}
	headers := []string{"Nr.", "Bezeichnung", "Typ", "Modell", "Los/Serienn.", "Hersteller", "Bevollm./Import.", "Betr.Kennung", "Standort", "Risiko", "Naechste STK", "Naechste MTK", "Anschaffung"}

	pdf.SetFont("Arial", "B", 6)
	pdf.SetFillColor(220, 220, 220)
	for i, h := range headers {
		pdf.CellFormat(colWidths[i], 7, h, "1", 0, "C", true, 0, "")
	}
	pdf.Ln(-1)

	// Table rows
	pdf.SetFont("Arial", "", 6)
	fill := false
	for idx, item := range items {
		if fill {
			pdf.SetFillColor(245, 245, 245)
		} else {
			pdf.SetFillColor(255, 255, 255)
		}

		nr := fmt.Sprintf("%d", idx+1)
		name := truncate(item.Name, 22)
		deviceType := deref(item.DeviceType)
		model := deref(item.DeviceModel)
		serial := deref(item.SerialNumber)
		manufacturer := deref(item.Manufacturer)
		rep := deref(item.AuthorizedRepresentative)
		if rep == "" {
			rep = deref(item.Importer)
		}
		opID := deref(item.OperationalIDNumber)
		location := deref(item.LocationAssignment)
		risk := deref(item.RiskClass)
		nextSTK := ""
		if item.NextStkDue != nil {
			nextSTK = item.NextStkDue.Format("2006-01-02")
		}
		nextMTK := ""
		if item.NextMtkDue != nil {
			nextMTK = item.NextMtkDue.Format("2006-01-02")
		}
		acqDate := ""
		if item.AcquisitionDate != nil {
			acqDate = item.AcquisitionDate.Format("2006-01-02")
		}

		pdf.CellFormat(colWidths[0], 6, nr, "1", 0, "C", fill, 0, "")
		pdf.CellFormat(colWidths[1], 6, name, "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[2], 6, truncate(deviceType, 14), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[3], 6, truncate(model, 14), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[4], 6, truncate(serial, 12), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[5], 6, truncate(manufacturer, 18), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[6], 6, truncate(rep, 14), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[7], 6, truncate(opID, 12), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[8], 6, truncate(location, 14), "1", 0, "L", fill, 0, "")
		pdf.CellFormat(colWidths[9], 6, risk, "1", 0, "C", fill, 0, "")
		pdf.CellFormat(colWidths[10], 6, nextSTK, "1", 0, "C", fill, 0, "")
		pdf.CellFormat(colWidths[11], 6, nextMTK, "1", 0, "C", fill, 0, "")
		pdf.CellFormat(colWidths[12], 6, acqDate, "1", 0, "C", fill, 0, "")
		pdf.Ln(-1)

		fill = !fill
	}

	if len(items) == 0 {
		pdf.SetFont("Arial", "I", 10)
		pdf.Ln(5)
		pdf.Cell(0, 10, "Keine Medizinprodukte erfasst / No medical devices registered.")
	}

	var buf bytes.Buffer
	if err := pdf.Output(&buf); err != nil {
		return nil, fmt.Errorf("failed to generate PDF: %w", err)
	}

	return buf.Bytes(), nil
}

func deref(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

func truncate(s string, maxLen int) string {
	runes := []rune(s)
	if len(runes) <= maxLen {
		return s
	}
	return string(runes[:maxLen-1]) + "…"
}
